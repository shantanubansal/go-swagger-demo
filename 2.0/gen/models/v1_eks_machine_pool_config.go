// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1EksMachinePoolConfig v1 eks machine pool config
//
// swagger:model v1EksMachinePoolConfig
type V1EksMachinePoolConfig struct {

	// additionalLabels
	AdditionalLabels map[string]string `json:"additionalLabels,omitempty"`

	// AdditionalTags is an optional set of tags to add to resources managed by the provider, in addition to the ones added by default. For eg., tags for EKS nodeGroup or EKS NodegroupIAMRole
	AdditionalTags map[string]string `json:"additionalTags,omitempty"`

	// AZs is only used for dynamic placement
	Azs []string `json:"azs"`

	// EC2 instance capacity type
	// Enum: [on-demand spot]
	CapacityType *string `json:"capacityType,omitempty"`

	// infra profile ref
	InfraProfileRef *V1ObjectReference `json:"infraProfileRef,omitempty"`

	// infra profile template
	InfraProfileTemplate *V1ClusterProfileTemplate `json:"infraProfileTemplate,omitempty"`

	// instance type
	InstanceType string `json:"instanceType,omitempty"`

	// whether this pool is for control plane
	// Required: true
	IsControlPlane *bool `json:"isControlPlane"`

	// labels for this pool, example: master/worker, gpu, windows
	Labels []string `json:"labels"`

	// machines
	Machines []*V1AwsMachine `json:"machines"`

	// max size of the pool, for scaling
	MaxSize int32 `json:"maxSize,omitempty"`

	// min size of the pool, for scaling
	MinSize int32 `json:"minSize,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// rootDeviceSize in GBs
	RootDeviceSize int64 `json:"rootDeviceSize,omitempty"`

	// size of the pool, number of machines
	Size int32 `json:"size,omitempty"`

	// spot market options
	SpotMarketOptions *V1SpotMarketOptions `json:"spotMarketOptions,omitempty"`

	// AZ to subnet mapping filled by ally from hubble SubnetIDs ["us-west-2d"] = "subnet-079b6061" This field is optional If we don't provide a subnetId then by default the first private subnet from the AZ will be picked up for deployment
	SubnetIds map[string]string `json:"subnetIds,omitempty"`

	// master or worker taints
	// Unique: true
	Taints []*V1Taint `json:"taints"`

	// update strategy
	UpdateStrategy *V1UpdateStrategy `json:"updateStrategy,omitempty"`

	// if IsControlPlane==true && useControlPlaneAsWorker==true, then will remove master taint this will not be used for worker pools
	UseControlPlaneAsWorker bool `json:"useControlPlaneAsWorker"`
}

// Validate validates this v1 eks machine pool config
func (m *V1EksMachinePoolConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCapacityType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfraProfileRef(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfraProfileTemplate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsControlPlane(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMachines(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpotMarketOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaints(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdateStrategy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1EksMachinePoolConfigTypeCapacityTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["on-demand","spot"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1EksMachinePoolConfigTypeCapacityTypePropEnum = append(v1EksMachinePoolConfigTypeCapacityTypePropEnum, v)
	}
}

const (

	// V1EksMachinePoolConfigCapacityTypeOnDemand captures enum value "on-demand"
	V1EksMachinePoolConfigCapacityTypeOnDemand string = "on-demand"

	// V1EksMachinePoolConfigCapacityTypeSpot captures enum value "spot"
	V1EksMachinePoolConfigCapacityTypeSpot string = "spot"
)

// prop value enum
func (m *V1EksMachinePoolConfig) validateCapacityTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, v1EksMachinePoolConfigTypeCapacityTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *V1EksMachinePoolConfig) validateCapacityType(formats strfmt.Registry) error {

	if swag.IsZero(m.CapacityType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCapacityTypeEnum("capacityType", "body", *m.CapacityType); err != nil {
		return err
	}

	return nil
}

func (m *V1EksMachinePoolConfig) validateInfraProfileRef(formats strfmt.Registry) error {

	if swag.IsZero(m.InfraProfileRef) { // not required
		return nil
	}

	if m.InfraProfileRef != nil {
		if err := m.InfraProfileRef.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("infraProfileRef")
			}
			return err
		}
	}

	return nil
}

func (m *V1EksMachinePoolConfig) validateInfraProfileTemplate(formats strfmt.Registry) error {

	if swag.IsZero(m.InfraProfileTemplate) { // not required
		return nil
	}

	if m.InfraProfileTemplate != nil {
		if err := m.InfraProfileTemplate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("infraProfileTemplate")
			}
			return err
		}
	}

	return nil
}

func (m *V1EksMachinePoolConfig) validateIsControlPlane(formats strfmt.Registry) error {

	if err := validate.Required("isControlPlane", "body", m.IsControlPlane); err != nil {
		return err
	}

	return nil
}

func (m *V1EksMachinePoolConfig) validateMachines(formats strfmt.Registry) error {

	if swag.IsZero(m.Machines) { // not required
		return nil
	}

	for i := 0; i < len(m.Machines); i++ {
		if swag.IsZero(m.Machines[i]) { // not required
			continue
		}

		if m.Machines[i] != nil {
			if err := m.Machines[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("machines" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1EksMachinePoolConfig) validateSpotMarketOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.SpotMarketOptions) { // not required
		return nil
	}

	if m.SpotMarketOptions != nil {
		if err := m.SpotMarketOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spotMarketOptions")
			}
			return err
		}
	}

	return nil
}

func (m *V1EksMachinePoolConfig) validateTaints(formats strfmt.Registry) error {

	if swag.IsZero(m.Taints) { // not required
		return nil
	}

	if err := validate.UniqueItems("taints", "body", m.Taints); err != nil {
		return err
	}

	for i := 0; i < len(m.Taints); i++ {
		if swag.IsZero(m.Taints[i]) { // not required
			continue
		}

		if m.Taints[i] != nil {
			if err := m.Taints[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1EksMachinePoolConfig) validateUpdateStrategy(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdateStrategy) { // not required
		return nil
	}

	if m.UpdateStrategy != nil {
		if err := m.UpdateStrategy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateStrategy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1EksMachinePoolConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1EksMachinePoolConfig) UnmarshalBinary(b []byte) error {
	var res V1EksMachinePoolConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
